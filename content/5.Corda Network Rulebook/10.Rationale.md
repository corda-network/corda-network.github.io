# Rationale

## Introduction

This sections is **not** a formal part of the Corda Network Rulebook. It provides explanation and justification for the rules contained in the Corda Network Rulebook, which the reader may find helpful.


### 1. Rationale for Constraints on Characters and Unicode

English benefits from a very simple alphabet. Many languages have more complex writing systems and this frequently  leads to a cascade of bugs and security holes when working with so-called "international text". Despite the decades of excellent work done by the Unicode Consortium on creating a global system for computerized text, it is still a complex area.

The rules above are designed to simplify Corda development for both R3 and app developers. Here is a subset of the problems we hope to avoid:

* Names that cannot be pronounced over the phone by support staff.
* Confusable character attacks, e.g. submitting an application for a name that already exists with letters like "o" 
swapped for their Cyrillic equivalents, thus creating what appears to a computer to be a unique name.
* Confusion attacks based on flipping text direction half way through a script that doesn't benefit from it. For 
instance, try copying the following word out of this email and into a text editor or terminal: "MegaproC".
You will find that it isn't quite what you expected.
* Varying Unicode canonicalization, for instance is the letter Ã¼ represented as a single character or as a u followed 
by the Â¨ combining character? NFKC form provides an answer.
* Some common software is critically buggy when faced with characters outside the Basic Multilingual Plane. MySQL in 
particular does not support the full range of Unicode inside UTF-8 fields. You have to specify the column type as 
utf8mb4 instead. If you don't, the non-BMP character and anything after it is silently truncated. This is not considered 
a bug by the MySQL developers and therefore does not get fixed. Facebook got hacked in this way.

It would imply a need to fully support complex scripts in end user apps, which may need to inter-operate with legacy mainframe based applications that do not handle Unicode properly.

The restriction on only supporting the extended Latin alphabet may be considered restrictive in some locales, as it effectively forbids the use of Arabic, Thai, Chinese, Hebrew etc in legal entity names. Even worse, it restricts the use of emoji ðŸ’”ðŸ˜¢.

The owners of names that lie outside the extended Latin alphabet must select a canonical transliteration before they apply for an identity in the main zone. Future versions of this policy may relax the naming requirements, probably in concert with new platform features to make it easier to work with such names (e.g. integrated transliteration facilities). The X.500 standard is used to disambiguate legal names using locality information, as company names are not globally unique (see https://stripe.ian.sh for an example of this).

Control characters are forbidden for obvious reasons.

The comma is forbidden because it is used to separate X.500 components when serialised to text. This rule is restrictive, and it may need to be removed, as commas are commonly found in legitimate legal names. The X.500 text format can escape commas by wrapping a component with double quotes, which is why " is also forbidden. Note that X.500 names are natively binary and thus do not suffer such escaping issues, but the prevalence of web apps and the entirely textual nature of the web protocol stack implies names should be easily worked with in textual forms too.

The = \ / and $ characters are forbidden due to the number of systems in which they are interpreted as having special meaning, and the low probability of them appearing in legitimate legal entity names.

Stopwords are implemented to catch the case where someone tries to give their Node a name that isn't a legal entity name but rather, specifies what it is (e.g. "MegaCorp Corda Node"). 

The first-letter-capitalized rule is to stop lazy admins submitting names like "hsbc corp". We want names that look good in user interfaces!

The selected Unicode version is the one supported by Java 8.

### 1.2. Developer Notes

Handling international text is a remarkably difficult task, filled with pitfalls for new and experienced engineers alike. For best results follow these recommendations:

* Do not be tempted to perform "looks alike" conversion into ASCII when attempting to inter-operate with legacy systems. If you 
absolutely cannot upgrade a target system to be Unicode aware, use ? as a replacement character. Mapping extended 
Latin characters to characters that English speakers think look the same has caused people to kill each other by 
accident (the linked article is not a joke).

* Names on the Corda Network should not be prepared for comparison using methods like toLowerCase() or toUpperCase() because some supported characters do not survive case round-tripping. For example the German letter ÃŸ converts to "SS" when upper-cased but, of course, "SS" converts to "ss" when lower-cased. Whilst making two pieces of text "human compares equal" by simply lower-casing or upper-casing is valid in English, in other languages some visual differences may be 
considered irrelevant yet not be removed by re-casing. A better approach is to use a java.text.Collator object, then call the setStrength method to determine how lax the match should be, and then check if the compare method returns zero.

* A Collator object should also be used to sort Corda Network names, for example if you wish to create an alphabetically sorted list of target names. Note that sorting (collation) rules change depending on the native language of the user. For example in Germany Ãœ sorts directly after U however in Swedish it is considered a separate letter and Ãœ will sort after Z. Therefore if you want to sort things alphabetically you should have some understanding of where your user is from. The HTTP Accept-Language header may seem tempting for this but it is common for users who are not native English speakers to put English first in their preference list, due to the abundance of poorly localized apps. So you may wish to obtain this information in different ways, or to pay attention to the first non-English language specified.

* When allowing the user to input free text for identities, use the CordaRPCOps.partiesFromName RPC to do lookups and set exactMatch to false. Don't attempt to download the network map or a BNO membership list and do your own matching - do the query first against the network map, then filter out members that are not in the BNO list. 

Corda will do fuzzy matching of names for you. This matching is likely to improve over time, at least in some implementations, e.g. by introducing Soundex matching, Jaro-Winkler or Levenshtein distance computation, automatic NFKC canonicalisation, Thai word breaking, spelling correction and so on. These tasks are extremely hard to do well in JavaScript so web app authors should pay particular attention to this point.

Future versions of the platform will probably include new APIs for guiding developers towards the right tools and behaviours here.

Please note that these guidelines are not exhaustive. 

**Potential Future Evolutions**

* Support for more alphabets like Chinese and its variants, Japanese, Thai, Arabic, Hebrew. This implies allowing right-to-left text in names and consequent policies designed to detect abuse.
* Allowing commas and quote characters for e.g. Irish names, name of law firms etc.
* Policy constraints on acceptable state, country names.
* Relaxation or removal of stopwords. Alternatively, addition of more stopwords e.g. swear words.
* Integration of Unicode confusable character detection algorithms.


### 2. Rationale for Event Horizon Policy

Corda nodes are not required to be online continuously. Like email servers, transient outages are tolerated by peer nodes buffering outbound messages to disk and retrying from time to time. Thus nodes can be restarted, upgraded and so on without causing any user visible problems beyond increased latency.

Although this design is robust, it does imply that nodes which go offline permanently (e.g. due to bankruptcy, seizure, destruction) would cause permanent resource leaks throughout the network as flows hang and retry delivery forever. Therefore there should be an upper bound at which point the node is assumed to never be returning, enabling message queues to be flushed and in-flight flows to be killed.

The event horizon should be long. If it is too low then there is a risk that recoverable outages are turned into major user-visible disruption because the event horizon is crossed unnecessarily. If it is too high then disk space and CPU time may be wasted, however the cost of this is likely to be very low compared to the cost of business disruption and required human attention.

In addition, the Corda Network may be extended in future to support nodes owned by small businesses and even sole  traders, which may go offline for weeks due to trivial events like taking a holiday or sickness. Therefore we propose that roughly one month provides a good balance of factors.

### 3. Rationale for Node IP Connectivity Policy

The world has run out of IPv4 addresses. IPv6 is clearly the future. Unfortunately [adoption is currently only at 25%](https://www.google.com/intl/en/ipv6/statistics.html) and whilst itâ€™s growing, so too is the disparity between weekend and weekday IPv6 traffic. This is because workplaces are slower to adopt IPv6 than consumer ISPs.

Corda nodes are meant to run on servers. Some data centres do not currently support IPv6, although the big cloud operators all do. However data-centres have been allocated enough IPv4 addresses that realistically it is very unlikely that a node operator will be unable to obtain one in the near future.

Like all blockchain networks the Corda network is flat with direct inter-node connectivity. The Corda Network Foundation does not sit in the middle and route messages. Therefore, all nodes must be able to build TCP/IP connections to each other in order to exchange data.

TCP/IP level firewall rules are a traditional way to regulate inter-business communications, however, there are no good standard protocols for altering them from inside the firewall and many organisations have built elaborate bureaucracies around doing so. If Corda nodes were to be firewalled at the TCP/IP level, the network would rapidly ossify and new members of a business network would experience multi-month delays whilst all the firewalls on all the other nodes were reconfigured. This would make Corda essentially useless.

Therefore, nodes should be protected with cryptographic firewalls. This is more secure as it is resistant to BGP hijacks and other forms of IP address takeover. TLS handshaking is used to verify the peer identity. Access control can be enforced by node configuration and/or at the app level. This reflects the intended configuration of a node that supports multiple collaborating apps in dynamic business networks, each of which may have its own notion of which counterparties are members.

### 4. Rationale for Port Ranges Policy

It is common for firewall operators to dislike the idea of opening more ports than the minimum. Therefore picking a single port on which Corda nodes may establish outbound connections may make it slightly easier to get through firewall bureaucracies at large institutions.
 
However there are two reasons for allowing outbound connections to any port:

* Although we are working on upgrading the Corda protocol to support [TLS SNI] (https://en.wikipedia.org/wiki/Server_Name_Indication), old nodes will not know how to use it. 
Until the minPlatformVersion for the Corda network is raised to a level that makes SNI support mandatory the only way to disambiguate a connection to an IP address that may host multiple identities is by port number.
* CorDapps may wish to make non-P2P connections, for instance, an app providing oracle services may want to connect to a web server via TLS to download data from an external provider.
 
If we picked a static port like 31337 - [a favourite](https://www.urbandictionary.com/define.php?term=31337) - then weâ€™d lose the ability to host multiple identities on 
a single IP address pre-SNI, and installing apps would become harder, because theyâ€™d often start out blocked.
 

**Possible Future Evolutions**

Whilst non-P2P connections made by apps may be restricted in future to reduce the trust needed in app developers, this would be a feature of a node implementation and not something that affects network level policy.
 
If CorDapps become sand-boxed (either by the node or by HTTP reverse proxies) such that they never need to make outbound connections on their own, and when minPlatformVersion is bumped high enough to eliminate non-SNI supporting implementations, both justifications for allowing the entire port range are gone. In this case the network may migrate to a single port number for all nodes, hence the recommendation. However this is a possible evolution and not a policy commitment.


